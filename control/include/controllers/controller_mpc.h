
#pragma once

#include <stdint.h>

#include "controller_interface.h"

#ifdef TARGET_ARCH_LINUX
	#include "osqp.h"
#endif


// TODO Fix this - bad way to do it

class MPC_Controller : public MC_Controller
{
	public:
		MPC_Controller();

	/* **MPC Controller Implementation**
	 *
	 * Takes a reference trajectory generated by the planner and generates an optimal control input, U,
	 * under controller constraints.
	 * 
	 * We use a 12-state vector for our states:
	 * - 0:3 Position (metres, inertial frame) (x,y,z)
	 * - 3:6 Attitude (radians, rotation from inertial to body) (roll, pitch, yaw)
	 * - 6:9 Velocity (m/s, inertial frame) (1st deriv. of position)
	 * - 9:12 Roll Rates (rad/s, body frame) (1st deriv. of attitude)
	 *
	 * Our control output U is a 4-state vector:
	 * - 0 Total Thrust (N)
	 * - 1 Roll Torque (N, about x-axis)
	 * - 2 Pitch Torque (N, about y-axis)
	 * - 3 Yaw Torque (N, about z-axis)
	 *
	 * In simulation, we run the planner at 100Hz and take the next control update.
	 *
	 * **Libraries**
	 * We use OSQP to solve the control problem at each iteration.
	 *
	 */

	/* A note on the OSQP code generation
	 *
	 * In our python script in control/design, we use OSQP to generate the boilerplate for our QP. This generates 
	 * three files that is specific to this problem: emosqp.c, workspace.h, and workspace.c .
	 *
	 */

	public:

		void run() override;

	private:

		OSQPInt exitflag;

		/* Aside from the variables that need to be changed, the full definitions of each of these should
		 * reside in something akin to the OSQP 'workspace.c' file where they are defined static to that TU
		 */

		OSQPFloat lower_constraint[240];
		OSQPFloat upper_constraint[240];

		OSQPFloat q_constraint[160];

		OSQPFloat linearised_A[144];
		OSQPFloat linearised_B[48];

		// NOTE This is now defined in the generated workspace.c file and externed
		//OSQPSolver solver;
		
		/* @brief This is the diagonals of the p-matrix. Because OSQP uses a csc-format, we cannot directly
		 * index the p-matrix so we instead store a copy and use that when updating the q-matrix. This should
		 * really be 160 length but there is no reference tracking/penalty for the inputs so we keep as 120 */
		OSQPFloat penalty_vector[120];

	private:

		/* @brief Buffer containing the full 12-state reference trajectory over the next 10 steps */
		OSQPFloat state_reference[120];

		/* @brief Keeps track of where in our buffer the state starts from */
		uint32_t state_reference_idx=0;

	public:
		/* @brief Updates the controller state reference with a full 10 step horizon 12-state vector */
		void update_state_reference(float* ref_array);

		/* @brief Updates the controller state reference with a constant 12-state horizon */
		void update_constant_state_reference(float* ref_array);

	private:
		/* @brief Mixer algorithm to generate PWM signals from control vector
		 * @param thrust The desired total thrust (in Newtons) from the four motors
		 * @param roll The desired roll torque (in newton-metres)
		 * @param pitch The desired pitch torque (in newton-metres)
		 * @param yaw The desired yaw torque (in newton-metres)
		 * @param exitflag The status output of the OQSP solver
		 */
		void mixer_generate_pwm(float thrust, float roll, float pitch, float yaw, uint16_t ef);


};

