
#pragma once

#include <stdint.h>

#include "control.h"

#ifdef TARGET_ARCH_LINUX
	#include "osqp.h"
#endif


// TODO Fix this - bad way to do it

class MPC_Controller : public MC_Controller
{
	public:
		MPC_Controller();

	/* **MPC Controller Implementation**
	 *
	 * Takes a reference trajectory generated by the planner and generates an optimal control input, U,
	 * under controller constraints.
	 * 
	 * We use a 12-state vector for our states:
	 * - 0:3 Position (metres, inertial frame) (x,y,z)
	 * - 3:6 Attitude (radians, rotation from inertial to body) (roll, pitch, yaw)
	 * - 6:9 Velocity (m/s, inertial frame) (1st deriv. of position)
	 * - 9:12 Roll Rates (rad/s, body frame) (1st deriv. of attitude)
	 *
	 * Our control output U is a 4-state vector:
	 * - 0 Total Thrust (N)
	 * - 1 Roll Torque (N, about x-axis)
	 * - 2 Pitch Torque (N, about y-axis)
	 * - 3 Yaw Torque (N, about z-axis)
	 *
	 * In simulation, we run the planner at 100Hz and take the next control update.
	 *
	 * **Libraries**
	 * We use OSQP to solve the control problem at each iteration.
	 *
	 */

	/* A note on the OSQP code generation
	 *
	 * In our python script in control/design, we use OSQP to generate the boilerplate for our QP. This generates 
	 * three files that is specific to this problem: emosqp.c, workspace.h, and workspace.c .
	 *
	 */

	public:

		void run() override;

	private:

		OSQPInt exitflag;

		/* Aside from the variables that need to be changed, the full definitions of each of these should
		 * reside in something akin to the OSQP 'workspace.c' file where they are defined static to that TU
		 */

		OSQPFloat lower_constraint[240];
		OSQPFloat upper_constraint[240];

		OSQPFloat q_constraint[160];

		OSQPFloat linearised_A[144];
		OSQPFloat linearised_B[48];

		// NOTE This is now defined in the generated workspace.c file and externed
		//OSQPSolver solver;

	private:

		/* @brief Buffer containing the full 12-state reference trajectory over the next 10 steps */
		OSQPFloat state_reference[120];

		/* @brief Keeps track of where in our buffer the state starts from */
		uint32_t state_reference_idx=0;

	public:

		void update_state_reference();

	private:
		/* @brief Mixer algorithm to generate PWM signals from control vector
		 * @param thrust The desired total thrust (in Newtons) from the four motors
		 * @param roll The desired roll torque (in newton-metres)
		 * @param pitch The desired pitch torque (in newton-metres)
		 * @param yaw The desired yaw torque (in newton-metres)
		 */
		void mixer_generate_pwm(float thrust, float roll, float pitch, float yaw);


};

