/*
 * This file was autogenerated by OSQP on Fri Jun  6 22:35:10 2025
 * 
 * This file contains a sample solver to run the embedded code.
 */

#include <stdio.h>
#include "osqp.h"
#include "workspace.h"

// TODO NOTE We need to re-use the original l_new matrix
#ifdef __cplusplus
extern "C" {
#endif
	extern OSQPFloat data_l_val[240];
	extern OSQPFloat data_u_val[240];
#ifdef __cplusplus
}
#endif

int main() {
  OSQPInt exitflag;

  printf( "Embedded test program for vector updates.\n");

  //exitflag = osqp_solve( &solver );

  /* Each iteration, update l and u with A@x_{0} for first 12 rows and
   * then update q matrix with -x_ref@P
   */

  // Initialise reference trajectory
  OSQPFloat x_ref[160];
  for (int i=0; i<10; i++) {
	  for (int j=0;j<16;j++) { 
		  x_ref[i*16+j] = 0.0f;
	  }

	  // update row with x_ref 
	  x_ref[i*12] = 4.0f;
	  x_ref[i*12+1] = 7.0f;
	  x_ref[i*12+2] = 10.0f;

  }

  OSQPFloat x0[12] = {3.0, 10.0, 2.0, 0.75, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};

  OSQPFloat q_new[160];
  for (int i=0;i<160;i++) q_new[i]=0.0f;


  float lin_A[144] = {
	1.0, // (0,0)
	0.0, // (0,1)
	0.0, // (0,2)
	0.0, // (0,3)
	0.049, // (0,4)
	0.0, // (0,5)
	0.09999999999999999, // (0,6)
	0.0, // (0,7)
	0.0, // (0,8)
	0.0, // (0,9)
	0.0016333333333333334, // (0,10)
	0.0, // (0,11)
	0.0, // (1,0)
	1.0, // (1,1)
	0.0, // (1,2)
	0.049, // (1,3)
	0.0, // (1,4)
	0.0, // (1,5)
	0.0, // (1,6)
	0.09999999999999999, // (1,7)
	0.0, // (1,8)
	0.0016333333333333334, // (1,9)
	0.0, // (1,10)
	0.0, // (1,11)
	0.0, // (2,0)
	0.0, // (2,1)
	1.0, // (2,2)
	0.0, // (2,3)
	0.0, // (2,4)
	0.0, // (2,5)
	0.0, // (2,6)
	0.0, // (2,7)
	0.09999999999999999, // (2,8)
	0.0, // (2,9)
	0.0, // (2,10)
	0.0, // (2,11)
	0.0, // (3,0)
	0.0, // (3,1)
	0.0, // (3,2)
	1.0, // (3,3)
	0.0, // (3,4)
	0.0, // (3,5)
	0.0, // (3,6)
	0.0, // (3,7)
	0.0, // (3,8)
	0.09999999999999999, // (3,9)
	0.0, // (3,10)
	0.0, // (3,11)
	0.0, // (4,0)
	0.0, // (4,1)
	0.0, // (4,2)
	0.0, // (4,3)
	1.0, // (4,4)
	0.0, // (4,5)
	0.0, // (4,6)
	0.0, // (4,7)
	0.0, // (4,8)
	0.0, // (4,9)
	0.09999999999999999, // (4,10)
	0.0, // (4,11)
	0.0, // (5,0)
	0.0, // (5,1)
	0.0, // (5,2)
	0.0, // (5,3)
	0.0, // (5,4)
	1.0, // (5,5)
	0.0, // (5,6)
	0.0, // (5,7)
	0.0, // (5,8)
	0.0, // (5,9)
	0.0, // (5,10)
	0.09999999999999999, // (5,11)
	0.0, // (6,0)
	0.0, // (6,1)
	0.0, // (6,2)
	0.0, // (6,3)
	0.9800000000000001, // (6,4)
	0.0, // (6,5)
	1.0, // (6,6)
	0.0, // (6,7)
	0.0, // (6,8)
	0.0, // (6,9)
	0.049, // (6,10)
	0.0, // (6,11)
	0.0, // (7,0)
	0.0, // (7,1)
	0.0, // (7,2)
	0.9800000000000001, // (7,3)
	0.0, // (7,4)
	0.0, // (7,5)
	0.0, // (7,6)
	1.0, // (7,7)
	0.0, // (7,8)
	0.049, // (7,9)
	0.0, // (7,10)
	0.0, // (7,11)
	0.0, // (8,0)
	0.0, // (8,1)
	0.0, // (8,2)
	0.0, // (8,3)
	0.0, // (8,4)
	0.0, // (8,5)
	0.0, // (8,6)
	0.0, // (8,7)
	1.0, // (8,8)
	0.0, // (8,9)
	0.0, // (8,10)
	0.0, // (8,11)
	0.0, // (9,0)
	0.0, // (9,1)
	0.0, // (9,2)
	0.0, // (9,3)
	0.0, // (9,4)
	0.0, // (9,5)
	0.0, // (9,6)
	0.0, // (9,7)
	0.0, // (9,8)
	1.0, // (9,9)
	0.0, // (9,10)
	0.0, // (9,11)
	0.0, // (10,0)
	0.0, // (10,1)
	0.0, // (10,2)
	0.0, // (10,3)
	0.0, // (10,4)
	0.0, // (10,5)
	0.0, // (10,6)
	0.0, // (10,7)
	0.0, // (10,8)
	0.0, // (10,9)
	1.0, // (10,10)
	0.0, // (10,11)
	0.0, // (11,0)
	0.0, // (11,1)
	0.0, // (11,2)
	0.0, // (11,3)
	0.0, // (11,4)
	0.0, // (11,5)
	0.0, // (11,6)
	0.0, // (11,7)
	0.0, // (11,8)
	0.0, // (11,9)
	0.0, // (11,10)
	1.0, // (11,11)
  };

  float lin_B[48] = {
	0.0, //B(0,0)
	0.0, //B(0,1)
	0.0003712121212121212, //B(0,2)
	0.0, //B(0,3)
	0.0, //B(1,0)
	0.0003712121212121212, //B(1,1)
	0.0, //B(1,2)
	0.0, //B(1,3)
	0.004999999999999999, //B(2,0)
	0.0, //B(2,1)
	0.0, //B(2,2)
	0.0, //B(2,3)
	0.0, //B(3,0)
	0.045454545454545456, //B(3,1)
	0.0, //B(3,2)
	0.0, //B(3,3)
	0.0, //B(4,0)
	0.0, //B(4,1)
	0.045454545454545456, //B(4,2)
	0.0, //B(4,3)
	0.0, //B(5,0)
	0.0, //B(5,1)
	0.0, //B(5,2)
	0.12499999999999999, //B(5,3)
	0.0, //B(6,0)
	0.0, //B(6,1)
	0.01484848484848485, //B(6,2)
	0.0, //B(6,3)
	0.0, //B(7,0)
	0.01484848484848485, //B(7,1)
	0.0, //B(7,2)
	0.0, //B(7,3)
	0.09999999999999999, //B(8,0)
	0.0, //B(8,1)
	0.0, //B(8,2)
	0.0, //B(8,3)
	0.0, //B(9,0)
	0.9090909090909092, //B(9,1)
	0.0, //B(9,2)
	0.0, //B(9,3)
	0.0, //B(10,0)
	0.0, //B(10,1)
	0.9090909090909092, //B(10,2)
	0.0, //B(10,3)
	0.0, //B(11,0)
	0.0, //B(11,1)
	0.0, //B(11,2)
	2.5, //B(11,3)
  };


  // Step through (20.0s)
  for (int iteration=0;iteration<200;iteration++) {
	  // Update vectors
	  
	  // **q vector** - repeat the negative element of x0 for the q vector
	  for (int i=0;i<10;i++) {
		  for (int j=0;j<12;j++) {
			  q_new[i*12+j] = -1*x_ref[i*12+j];
		  }
	  }

	  // **l and u vectors**
	  for (int i=0;i<12;i++) {
		  data_l_val[120+i] = 0.0f;
		  for (int j=0;j<12;j++) {
			  /* Here, we are reusing the original l and u matrices so as to not remove the other constraints.
			   * Our state dynamic constraints start at index 120 */
			  data_l_val[120+i] += lin_A[i*12+j]*x0[j];
		  }
		  data_u_val[120+i] = data_l_val[120+i];
	  }

	  // Update solver with new matrices
	  osqp_update_data_vec(&solver, q_new, data_l_val, data_u_val);

	  // Solve
	  exitflag = osqp_solve( &solver );

	  if( exitflag > 0 ) {
		printf( "  OSQP errored: %s\n", osqp_error_message(exitflag));
		return (int)exitflag;
	  } else {
		//printf("Solved workspace with no error.\n" );
	  }
	  
	  // Log solution 

	  // Update dynamics model
	  for (int i=0;i<12;i++) {
		  float state_hold=0.0f;
		  
		  // Compute A*x
		  for (int j=0;j<12;j++) {
			  state_hold += lin_A[i*12+j]*x0[j];
		  }

		  // Compute B*u with u being the first control action from the previously solved state
		  for (int j=0;j<4;j++) {
			  state_hold += lin_B[i*4+j]*solver.solution->x[120+j];
		  }

		  // Assign to x_{i+1}
		  x0[i] = state_hold;
	  }
		
	  printf("State after iteration %d ", iteration);
	  for (int i=0;i<12;i++) {
		  printf("%4.2f ", x0[i]);
	  }
	  printf("\n");

  }

}
